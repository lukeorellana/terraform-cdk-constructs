// generated by cdktf get
// Azure/avm-res-keyvault-vault/azurerm
import { TerraformModule, TerraformModuleUserConfig } from 'cdktf';
import { Construct } from 'constructs';
export interface KeyvaultConfig extends TerraformModuleUserConfig {
  /**
  * A map of contacts for the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.
  * [object Object]
  */
  readonly contacts?: any;
  /**
  * A map of diagnostic settings to create on the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.

- `name` - (Optional) The name of the diagnostic setting. One will be generated if not set, however this will not be unique if you want to create multiple diagnostic setting resources.
- `log_categories` - (Optional) A set of log categories to send to the log analytics workspace. Defaults to `[]`.
- `log_groups` - (Optional) A set of log groups to send to the log analytics workspace. Defaults to `["allLogs"]`.
- `metric_categories` - (Optional) A set of metric categories to send to the log analytics workspace. Defaults to `["AllMetrics"]`.
- `log_analytics_destination_type` - (Optional) The destination type for the diagnostic setting. Possible values are `Dedicated` and `AzureDiagnostics`. Defaults to `Dedicated`.
- `workspace_resource_id` - (Optional) The resource ID of the log analytics workspace to send logs and metrics to.
- `storage_account_resource_id` - (Optional) The resource ID of the storage account to send logs and metrics to.
- `event_hub_authorization_rule_resource_id` - (Optional) The resource ID of the event hub authorization rule to send logs and metrics to.
- `event_hub_name` - (Optional) The name of the event hub. If none is specified, the default event hub will be selected.
- `marketplace_partner_resource_id` - (Optional) The full ARM resource ID of the Marketplace resource to which you would like to send Diagnostic LogsLogs.

  * [object Object]
  */
  readonly diagnosticSettings?: any;
  /**
  * This variable controls whether or not telemetry is enabled for the module.
For more information see https://aka.ms/avm/telemetryinfo.
If it is set to false, then no telemetry will be collected.

  * true
  */
  readonly enableTelemetry?: boolean;
  /**
  * Specifies whether Azure Virtual Machines are permitted to retrieve certificates stored as secrets from the vault.
  */
  readonly enabledForDeployment?: boolean;
  /**
  * Specifies whether Azure Disk Encryption is permitted to retrieve secrets from the vault and unwrap keys.
  */
  readonly enabledForDiskEncryption?: boolean;
  /**
  * Specifies whether Azure Resource Manager is permitted to retrieve secrets from the vault.
  */
  readonly enabledForTemplateDeployment?: boolean;
  /**
  * A map of keys to create on the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.

- `name` - The name of the key.
- `key_type` - The type of the key. Possible values are `EC` and `RSA`.
- `key_opts` - A list of key options. Possible values are `decrypt`, `encrypt`, `sign`, `unwrapKey`, `verify`, and `wrapKey`.
- `key_size` - The size of the key. Required for `RSA` keys.
- `curve` - The curve of the key. Required for `EC` keys.  Possible values are `P-256`, `P-256K`, `P-384`, and `P-521`. The API will default to `P-256` if nothing is specified.
- `not_before_date` - The not before date of the key.
- `expiration_date` - The expiration date of the key.
- `tags` - A mapping of tags to assign to the key.
- `rotation_policy` - The rotation policy of the key.
  - `automatic` - The automatic rotation policy of the key.
    - `time_after_creation` - The time after creation of the key before it is automatically rotated.
    - `time_before_expiry` - The time before expiry of the key before it is automatically rotated.
  - `expire_after` - The time after which the key expires.
  - `notify_before_expiry` - The time before expiry of the key when notification emails will be sent.

Supply role assignments in the same way as for `var.role_assignments`.

  * [object Object]
  */
  readonly keys?: any;
  /**
  * A map of legacy access policies to create on the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.

Requires `var.legacy_access_policies_enabled` to be `true`.

- `object_id` - (Required) The object ID of the principal to assign the access policy to.
- `application_id` - (Optional) The object ID of an Application in Azure Active Directory. Changing this forces a new resource to be created.
- `certifiate_permissions` - (Optional) A list of certificate permissions. Possible values are: `Backup`, `Create`, `Delete`, `DeleteIssuers`, `Get`, `GetIssuers`, `Import`, `List`, `ListIssuers`, `ManageContacts`, `ManageIssuers`, `Purge`, `Recover`, `Restore`, `SetIssuers`, and `Update`.
- `key_permissions` - (Optional) A list of key permissions. Possible value are: `Backup`, `Create`, `Decrypt`, `Delete`, `Encrypt`, `Get`, `Import`, `List`, `Purge`, `Recover`, `Restore`, `Sign`, `UnwrapKey`, `Update`, `Verify`, `WrapKey`, `Release`, `Rotate`, `GetRotationPolicy`, and `SetRotationPolicy`.
- `secret_permissions` - (Optional) A list of secret permissions. Possible values are: `Backup`, `Delete`, `Get`, `List`, `Purge`, `Recover`, `Restore`, and `Set`.
- `storage_permissions` - (Optional) A list of storage permissions. Possible values are: `Backup`, `Delete`, `DeleteSAS`, `Get`, `GetSAS`, `List`, `ListSas`, `Purge`, `Recover`, `RegenerateKey`, `Restore`, `Set`, `SetSAS`, and `Update`.

  * [object Object]
  */
  readonly legacyAccessPolicies?: any;
  /**
  * Specifies whether legacy access policies are enabled for this Key Vault. Prevents use of Azure RBAC for data plane.
  */
  readonly legacyAccessPoliciesEnabled?: boolean;
  /**
  * The Azure location where the resources will be deployed.
  */
  readonly location: string;
  /**
  * The lock level to apply to the Key Vault. Default is `None`. Possible values are `None`, `CanNotDelete`, and `ReadOnly`.
  */
  readonly lock?: any;
  /**
  * The name of the Key Vault.
  */
  readonly name: string;
  /**
  * The network ACL configuration for the Key Vault.
If not specified then the Key Vault will be created with a firewall that blocks access.
Specify `null` to create the Key Vault with no firewall.

- `bypass` - (Optional) Should Azure Services bypass the ACL. Possible values are `AzureServices` and `None`. Defaults to `None`.
- `default_action` - (Optional) The default action when no rule matches. Possible values are `Allow` and `Deny`. Defaults to `Deny`.
- `ip_rules` - (Optional) A list of IP rules in CIDR format. Defaults to `[]`.
- `virtual_network_subnet_ids` - (Optional) When using with Service Endpoints, a list of subnet IDs to associate with the Key Vault. Defaults to `[]`.

  * [object Object]
  */
  readonly networkAcls?: any;
  /**
  * A map of private endpoints to create on the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.

- `name` - (Optional) The name of the private endpoint. One will be generated if not set.
- `role_assignments` - (Optional) A map of role assignments to create on the private endpoint. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time. See `var.role_assignments` for more information.
- `lock` - (Optional) The lock level to apply to the private endpoint. Default is `None`. Possible values are `None`, `CanNotDelete`, and `ReadOnly`.
- `tags` - (Optional) A mapping of tags to assign to the private endpoint.
- `subnet_resource_id` - The resource ID of the subnet to deploy the private endpoint in.
- `private_dns_zone_group_name` - (Optional) The name of the private DNS zone group. One will be generated if not set.
- `private_dns_zone_resource_ids` - (Optional) A set of resource IDs of private DNS zones to associate with the private endpoint. If not set, no zone groups will be created and the private endpoint will not be associated with any private DNS zones. DNS records must be managed external to this module.
- `application_security_group_resource_ids` - (Optional) A map of resource IDs of application security groups to associate with the private endpoint. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.
- `private_service_connection_name` - (Optional) The name of the private service connection. One will be generated if not set.
- `network_interface_name` - (Optional) The name of the network interface. One will be generated if not set.
- `location` - (Optional) The Azure location where the resources will be deployed. Defaults to the location of the resource group.
- `resource_group_name` - (Optional) The resource group where the resources will be deployed. Defaults to the resource group of the Key Vault.
- `ip_configurations` - (Optional) A map of IP configurations to create on the private endpoint. If not specified the platform will create one. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.
  - `name` - The name of the IP configuration.
  - `private_ip_address` - The private IP address of the IP configuration.

  * [object Object]
  */
  readonly privateEndpoints?: any;
  /**
  * Whether to manage private DNS zone groups with this module. If set to false, you must manage private DNS zone groups externally, e.g. using Azure Policy.
  * true
  */
  readonly privateEndpointsManageDnsZoneGroup?: boolean;
  /**
  * Specifies whether public access is permitted.
  * true
  */
  readonly publicNetworkAccessEnabled?: boolean;
  /**
  * Specifies whether protection against purge is enabled for this Key Vault. Note once enabled this cannot be disabled.
  * true
  */
  readonly purgeProtectionEnabled?: boolean;
  /**
  * The resource group where the resources will be deployed.
  */
  readonly resourceGroupName: string;
  /**
  * A map of role assignments to create on the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.

- `role_definition_id_or_name` - The ID or name of the role definition to assign to the principal.
- `principal_id` - The ID of the principal to assign the role to.
- `description` - The description of the role assignment.
- `skip_service_principal_aad_check` - If set to true, skips the Azure Active Directory check for the service principal in the tenant. Defaults to false.
- `condition` - The condition which will be used to scope the role assignment.
- `condition_version` - The version of the condition syntax. If you are using a condition, valid values are '2.0'.

> Note: only set `skip_service_principal_aad_check` to true if you are assigning a role to a service principal.

  * [object Object]
  */
  readonly roleAssignments?: any;
  /**
  * A map of secrets to create on the Key Vault. The map key is deliberately arbitrary to avoid issues where map keys maybe unknown at plan time.

- `name` - The name of the secret.
- `content_type` - The content type of the secret.
- `tags` - A mapping of tags to assign to the secret.
- `not_before_date` - The not before date of the secret.
- `expiration_date` - The expiration date of the secret.

Supply role assignments in the same way as for `var.role_assignments`.

> Note: the `value` of the secret is supplied via the `var.secrets_value` variable. Make sure to use the same map key.

  * [object Object]
  */
  readonly secrets?: any;
  /**
  * A map of secret keys to values.
The map key is the supplied input to `var.secrets`.
The map value is the secret value.

This is a separate variable to `var.secrets` because it is sensitive and therefore cannot be used in a `for_each` loop.

  * The property type contains a map, they have special handling, please see {@link cdk.tf/module-map-inputs the docs}
  */
  readonly secretsValue?: { [key: string]: string };
  /**
  * The SKU name of the Key Vault. Default is `premium`. Possible values are `standard` and `premium`.
  * premium
  */
  readonly skuName?: string;
  /**
  * The number of days that items should be retained for once soft-deleted. This value can be between 7 and 90 (the default) days.

  */
  readonly softDeleteRetentionDays?: number;
  /**
  * Map of tags to assign to the Key Vault resource.
  * The property type contains a map, they have special handling, please see {@link cdk.tf/module-map-inputs the docs}
  */
  readonly tags?: { [key: string]: string };
  /**
  * The Azure tenant ID used for authenticating requests to Key Vault. You can use the `azurerm_client_config` data source to retrieve it.
  */
  readonly tenantId: string;
  /**
  * This variable controls the amount of time to wait before performing contact operations.
It only applies when `var.role_assignments` and `var.contacts` are both set.
This is useful when you are creating role assignments on the key vault and immediately creating keys in it.
The default is 30 seconds for create and 0 seconds for destroy.

  * [object Object]
  */
  readonly waitForRbacBeforeContactOperations?: any;
  /**
  * This variable controls the amount of time to wait before performing key operations.
It only applies when `var.role_assignments` and `var.keys` are both set.
This is useful when you are creating role assignments on the key vault and immediately creating keys in it.
The default is 30 seconds for create and 0 seconds for destroy.

  * [object Object]
  */
  readonly waitForRbacBeforeKeyOperations?: any;
  /**
  * This variable controls the amount of time to wait before performing secret operations.
It only applies when `var.role_assignments` and `var.secrets` are both set.
This is useful when you are creating role assignments on the key vault and immediately creating secrets in it.
The default is 30 seconds for create and 0 seconds for destroy.

  * [object Object]
  */
  readonly waitForRbacBeforeSecretOperations?: any;
}
/**
* Defines an Keyvault based on a Terraform module
*
* Docs at Terraform Registry: {@link https://registry.terraform.io/modules/Azure/avm-res-keyvault-vault/azurerm/0.9.1 Azure/avm-res-keyvault-vault/azurerm}
*/
export class Keyvault extends TerraformModule {
  private readonly inputs: { [name: string]: any } = { }
  public constructor(scope: Construct, id: string, config: KeyvaultConfig) {
    super(scope, id, {
      ...config,
      source: 'Azure/avm-res-keyvault-vault/azurerm',
      version: '0.9.1',
    });
    this.contacts = config.contacts;
    this.diagnosticSettings = config.diagnosticSettings;
    this.enableTelemetry = config.enableTelemetry;
    this.enabledForDeployment = config.enabledForDeployment;
    this.enabledForDiskEncryption = config.enabledForDiskEncryption;
    this.enabledForTemplateDeployment = config.enabledForTemplateDeployment;
    this.keys = config.keys;
    this.legacyAccessPolicies = config.legacyAccessPolicies;
    this.legacyAccessPoliciesEnabled = config.legacyAccessPoliciesEnabled;
    this.location = config.location;
    this.lock = config.lock;
    this.name = config.name;
    this.networkAcls = config.networkAcls;
    this.privateEndpoints = config.privateEndpoints;
    this.privateEndpointsManageDnsZoneGroup = config.privateEndpointsManageDnsZoneGroup;
    this.publicNetworkAccessEnabled = config.publicNetworkAccessEnabled;
    this.purgeProtectionEnabled = config.purgeProtectionEnabled;
    this.resourceGroupName = config.resourceGroupName;
    this.roleAssignments = config.roleAssignments;
    this.secrets = config.secrets;
    this.secretsValue = config.secretsValue;
    this.skuName = config.skuName;
    this.softDeleteRetentionDays = config.softDeleteRetentionDays;
    this.tags = config.tags;
    this.tenantId = config.tenantId;
    this.waitForRbacBeforeContactOperations = config.waitForRbacBeforeContactOperations;
    this.waitForRbacBeforeKeyOperations = config.waitForRbacBeforeKeyOperations;
    this.waitForRbacBeforeSecretOperations = config.waitForRbacBeforeSecretOperations;
  }
  public get contacts(): any | undefined {
    return this.inputs['contacts'] as any | undefined;
  }
  public set contacts(value: any | undefined) {
    this.inputs['contacts'] = value;
  }
  public get diagnosticSettings(): any | undefined {
    return this.inputs['diagnostic_settings'] as any | undefined;
  }
  public set diagnosticSettings(value: any | undefined) {
    this.inputs['diagnostic_settings'] = value;
  }
  public get enableTelemetry(): boolean | undefined {
    return this.inputs['enable_telemetry'] as boolean | undefined;
  }
  public set enableTelemetry(value: boolean | undefined) {
    this.inputs['enable_telemetry'] = value;
  }
  public get enabledForDeployment(): boolean | undefined {
    return this.inputs['enabled_for_deployment'] as boolean | undefined;
  }
  public set enabledForDeployment(value: boolean | undefined) {
    this.inputs['enabled_for_deployment'] = value;
  }
  public get enabledForDiskEncryption(): boolean | undefined {
    return this.inputs['enabled_for_disk_encryption'] as boolean | undefined;
  }
  public set enabledForDiskEncryption(value: boolean | undefined) {
    this.inputs['enabled_for_disk_encryption'] = value;
  }
  public get enabledForTemplateDeployment(): boolean | undefined {
    return this.inputs['enabled_for_template_deployment'] as boolean | undefined;
  }
  public set enabledForTemplateDeployment(value: boolean | undefined) {
    this.inputs['enabled_for_template_deployment'] = value;
  }
  public get keys(): any | undefined {
    return this.inputs['keys'] as any | undefined;
  }
  public set keys(value: any | undefined) {
    this.inputs['keys'] = value;
  }
  public get legacyAccessPolicies(): any | undefined {
    return this.inputs['legacy_access_policies'] as any | undefined;
  }
  public set legacyAccessPolicies(value: any | undefined) {
    this.inputs['legacy_access_policies'] = value;
  }
  public get legacyAccessPoliciesEnabled(): boolean | undefined {
    return this.inputs['legacy_access_policies_enabled'] as boolean | undefined;
  }
  public set legacyAccessPoliciesEnabled(value: boolean | undefined) {
    this.inputs['legacy_access_policies_enabled'] = value;
  }
  public get location(): string {
    return this.inputs['location'] as string;
  }
  public set location(value: string) {
    this.inputs['location'] = value;
  }
  public get lock(): any | undefined {
    return this.inputs['lock'] as any | undefined;
  }
  public set lock(value: any | undefined) {
    this.inputs['lock'] = value;
  }
  public get name(): string {
    return this.inputs['name'] as string;
  }
  public set name(value: string) {
    this.inputs['name'] = value;
  }
  public get networkAcls(): any | undefined {
    return this.inputs['network_acls'] as any | undefined;
  }
  public set networkAcls(value: any | undefined) {
    this.inputs['network_acls'] = value;
  }
  public get privateEndpoints(): any | undefined {
    return this.inputs['private_endpoints'] as any | undefined;
  }
  public set privateEndpoints(value: any | undefined) {
    this.inputs['private_endpoints'] = value;
  }
  public get privateEndpointsManageDnsZoneGroup(): boolean | undefined {
    return this.inputs['private_endpoints_manage_dns_zone_group'] as boolean | undefined;
  }
  public set privateEndpointsManageDnsZoneGroup(value: boolean | undefined) {
    this.inputs['private_endpoints_manage_dns_zone_group'] = value;
  }
  public get publicNetworkAccessEnabled(): boolean | undefined {
    return this.inputs['public_network_access_enabled'] as boolean | undefined;
  }
  public set publicNetworkAccessEnabled(value: boolean | undefined) {
    this.inputs['public_network_access_enabled'] = value;
  }
  public get purgeProtectionEnabled(): boolean | undefined {
    return this.inputs['purge_protection_enabled'] as boolean | undefined;
  }
  public set purgeProtectionEnabled(value: boolean | undefined) {
    this.inputs['purge_protection_enabled'] = value;
  }
  public get resourceGroupName(): string {
    return this.inputs['resource_group_name'] as string;
  }
  public set resourceGroupName(value: string) {
    this.inputs['resource_group_name'] = value;
  }
  public get roleAssignments(): any | undefined {
    return this.inputs['role_assignments'] as any | undefined;
  }
  public set roleAssignments(value: any | undefined) {
    this.inputs['role_assignments'] = value;
  }
  public get secrets(): any | undefined {
    return this.inputs['secrets'] as any | undefined;
  }
  public set secrets(value: any | undefined) {
    this.inputs['secrets'] = value;
  }
  public get secretsValue(): { [key: string]: string } | undefined {
    return this.inputs['secrets_value'] as { [key: string]: string } | undefined;
  }
  public set secretsValue(value: { [key: string]: string } | undefined) {
    this.inputs['secrets_value'] = value;
  }
  public get skuName(): string | undefined {
    return this.inputs['sku_name'] as string | undefined;
  }
  public set skuName(value: string | undefined) {
    this.inputs['sku_name'] = value;
  }
  public get softDeleteRetentionDays(): number | undefined {
    return this.inputs['soft_delete_retention_days'] as number | undefined;
  }
  public set softDeleteRetentionDays(value: number | undefined) {
    this.inputs['soft_delete_retention_days'] = value;
  }
  public get tags(): { [key: string]: string } | undefined {
    return this.inputs['tags'] as { [key: string]: string } | undefined;
  }
  public set tags(value: { [key: string]: string } | undefined) {
    this.inputs['tags'] = value;
  }
  public get tenantId(): string {
    return this.inputs['tenant_id'] as string;
  }
  public set tenantId(value: string) {
    this.inputs['tenant_id'] = value;
  }
  public get waitForRbacBeforeContactOperations(): any | undefined {
    return this.inputs['wait_for_rbac_before_contact_operations'] as any | undefined;
  }
  public set waitForRbacBeforeContactOperations(value: any | undefined) {
    this.inputs['wait_for_rbac_before_contact_operations'] = value;
  }
  public get waitForRbacBeforeKeyOperations(): any | undefined {
    return this.inputs['wait_for_rbac_before_key_operations'] as any | undefined;
  }
  public set waitForRbacBeforeKeyOperations(value: any | undefined) {
    this.inputs['wait_for_rbac_before_key_operations'] = value;
  }
  public get waitForRbacBeforeSecretOperations(): any | undefined {
    return this.inputs['wait_for_rbac_before_secret_operations'] as any | undefined;
  }
  public set waitForRbacBeforeSecretOperations(value: any | undefined) {
    this.inputs['wait_for_rbac_before_secret_operations'] = value;
  }
  public get keysResourceIdsOutput() {
    return this.getString('keys_resource_ids')
  }
  public get privateEndpointsOutput() {
    return this.getString('private_endpoints')
  }
  public get resourceIdOutput() {
    return this.getString('resource_id')
  }
  public get secretsResourceIdsOutput() {
    return this.getString('secrets_resource_ids')
  }
  public get uriOutput() {
    return this.getString('uri')
  }
  protected synthesizeAttributes() {
    return this.inputs;
  }
}
